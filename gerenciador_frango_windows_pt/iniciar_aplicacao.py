#!/usr/bin/env python3
"""
Gerenciador de Granjas de Frango - Vers√£o Windows
Lan√ßador compat√≠vel com Windows que usa Python diretamente
"""

import subprocess
import time
import webbrowser
import os
import sys
import signal
import threading
from pathlib import Path

# Configura√ß√£o
FRONTEND_PORT = 3000
BACKEND_PORT = 8001
FRONTEND_URL = f"http://127.0.0.1:{FRONTEND_PORT}"

class GerenciadorGranjaFrango:
    def __init__(self):
        self.backend_process = None
        self.frontend_process = None
        self.base_dir = Path(__file__).parent
        
    def verificar_python(self):
        """Verificar se Python est√° dispon√≠vel"""
        try:
            python_cmd = 'python' if os.name == 'nt' else 'python3'
            result = subprocess.run([python_cmd, '--version'], 
                                  capture_output=True, text=True)
            print(f"‚úÖ Python encontrado: {result.stdout.strip()}")
            return python_cmd
        except Exception as e:
            print(f"‚ùå Python n√£o encontrado: {e}")
            print("Por favor, instale Python 3.7+ do site python.org")
            return None
            
    def instalar_dependencias(self):
        """Instalar depend√™ncias do backend se necess√°rio"""
        try:
            python_cmd = self.verificar_python()
            if not python_cmd:
                return False
                
            print("üîç Verificando depend√™ncias...")
            
            # Verificar se as depend√™ncias est√£o instaladas
            required_packages = ['fastapi', 'uvicorn', 'pydantic', 'reportlab']
            missing_packages = []
            
            for package in required_packages:
                try:
                    subprocess.run([python_cmd, '-c', f'import {package}'], 
                                 check=True, capture_output=True)
                except subprocess.CalledProcessError:
                    missing_packages.append(package)
            
            if missing_packages:
                print(f"üì¶ Instalando depend√™ncias faltantes: {missing_packages}")
                subprocess.run([python_cmd, '-m', 'pip', 'install'] + missing_packages, 
                             check=True)
                print("‚úÖ Depend√™ncias instaladas com sucesso!")
            else:
                print("‚úÖ Todas as depend√™ncias est√£o instaladas!")
                
            return True
            
        except Exception as e:
            print(f"‚ùå Erro ao instalar depend√™ncias: {e}")
            return False
        
    def iniciar_backend(self):
        """Iniciar o servidor backend usando Python"""
        try:
            python_cmd = self.verificar_python()
            if not python_cmd:
                return False
                
            print("üöÄ Iniciando servidor backend...")
            
            # Usar uvicorn para iniciar o servidor
            self.backend_process = subprocess.Popen([
                python_cmd, '-m', 'uvicorn', 'server:app',
                '--host', '127.0.0.1',
                '--port', str(BACKEND_PORT),
                '--reload'
            ], cwd=str(self.base_dir))
            
            # Aguardar o backend iniciar
            print("‚è≥ Aguardando backend inicializar...")
            time.sleep(5)
            
            # Verificar se o processo ainda est√° rodando
            if self.backend_process.poll() is not None:
                print("‚ùå Backend falhou ao iniciar")
                return False
                
            # Testar conectividade
            try:
                import requests
                response = requests.get(f'http://127.0.0.1:{BACKEND_PORT}/api/', timeout=5)
                if response.status_code == 200:
                    print(f"‚úÖ Backend iniciado com sucesso (PID: {self.backend_process.pid})")
                    return True
                else:
                    print(f"‚ùå Backend n√£o respondeu corretamente: {response.status_code}")
                    return False
            except ImportError:
                # Se requests n√£o estiver dispon√≠vel, assumir que funcionou
                print(f"‚úÖ Backend iniciado (PID: {self.backend_process.pid})")
                return True
            except Exception as e:
                print(f"‚ùå Erro ao testar backend: {e}")
                return False
                
        except Exception as e:
            print(f"‚ùå Erro ao iniciar backend: {e}")
            return False
    
    def iniciar_frontend(self):
        """Iniciar o servidor frontend"""
        try:
            python_cmd = self.verificar_python()
            if not python_cmd:
                return False
                
            frontend_build_dir = self.base_dir / "frontend" / "build"
            if not frontend_build_dir.exists():
                print("‚ùå Frontend build n√£o encontrado. Executando build...")
                return self.build_frontend()
            
            print("üåê Iniciando servidor frontend...")
            
            # Iniciar servidor HTTP Python para frontend
            self.frontend_process = subprocess.Popen([
                python_cmd, '-m', 'http.server', str(FRONTEND_PORT),
                '--bind', '127.0.0.1'
            ], cwd=str(frontend_build_dir),
               stdout=subprocess.DEVNULL, 
               stderr=subprocess.DEVNULL)
            
            # Aguardar o frontend iniciar
            time.sleep(3)
            
            if self.frontend_process.poll() is not None:
                print("‚ùå Servidor frontend falhou ao iniciar")
                return False
                
            print(f"‚úÖ Servidor frontend iniciado (PID: {self.frontend_process.pid})")
            return True
            
        except Exception as e:
            print(f"‚ùå Falha ao iniciar frontend: {e}")
            return False
    
    def build_frontend(self):
        """Construir o frontend se necess√°rio"""
        try:
            frontend_dir = self.base_dir / "frontend"
            if not frontend_dir.exists():
                print("‚ùå Diret√≥rio frontend n√£o encontrado")
                return False
                
            print("üî® Construindo frontend...")
            
            # Verificar se npm/yarn est√° dispon√≠vel
            npm_cmd = 'npm'
            if os.name == 'nt':
                npm_cmd = 'npm.cmd'
                
            # Instalar depend√™ncias
            subprocess.run([npm_cmd, 'install'], cwd=str(frontend_dir), check=True)
            
            # Build
            subprocess.run([npm_cmd, 'run', 'build'], cwd=str(frontend_dir), check=True)
            
            print("‚úÖ Frontend constru√≠do com sucesso!")
            return True
            
        except Exception as e:
            print(f"‚ùå Erro ao construir frontend: {e}")
            print("üí° Certifique-se de que Node.js est√° instalado")
            return False
    
    def abrir_navegador(self):
        """Abrir a aplica√ß√£o no navegador padr√£o"""
        try:
            print(f"üåê Abrindo navegador em {FRONTEND_URL}...")
            webbrowser.open(FRONTEND_URL)
            print("‚úÖ Navegador aberto com sucesso")
        except Exception as e:
            print(f"‚ùå Falha ao abrir navegador: {e}")
            print(f"üîó Por favor, abra manualmente: {FRONTEND_URL}")
    
    def parar_servicos(self):
        """Parar todos os servi√ßos"""
        print("\nüõë Parando servi√ßos...")
        
        if self.frontend_process and self.frontend_process.poll() is None:
            try:
                self.frontend_process.terminate()
                self.frontend_process.wait(timeout=5)
                print("‚úÖ Servidor frontend parado")
            except:
                self.frontend_process.kill()
                print("üî• Servidor frontend for√ßado a parar")
        
        if self.backend_process and self.backend_process.poll() is None:
            try:
                self.backend_process.terminate()
                self.backend_process.wait(timeout=5)
                print("‚úÖ Servidor backend parado")
            except:
                self.backend_process.kill()
                print("üî• Servidor backend for√ßado a parar")
    
    def manipulador_sinal(self, signum, frame):
        """Manipular Ctrl+C e outros sinais de termina√ß√£o"""
        print("\n‚ö†Ô∏è Sinal de termina√ß√£o recebido...")
        self.parar_servicos()
        sys.exit(0)
    
    def executar(self):
        """Ponto de entrada principal da aplica√ß√£o"""
        # Configurar manipuladores de sinal
        try:
            signal.signal(signal.SIGINT, self.manipulador_sinal)
            signal.signal(signal.SIGTERM, self.manipulador_sinal)
        except:
            pass  # Windows pode n√£o suportar todos os sinais
        
        print("üêî GERENCIADOR DE GRANJAS DE FRANGO - VERS√ÉO WINDOWS")
        print("=" * 60)
        print("üáßüá∑ Interface 100% em Portugu√™s Brasileiro")
        print("üíª Compat√≠vel com Windows, Linux e macOS")
        print("=" * 60)
        
        try:
            # Verificar Python
            if not self.verificar_python():
                input("Pressione Enter para sair...")
                return 1
            
            # Instalar depend√™ncias
            if not self.instalar_dependencias():
                input("Pressione Enter para sair...")
                return 1
            
            # Iniciar backend
            print("\nüîß INICIALIZANDO SERVI√áOS...")
            if not self.iniciar_backend():
                print("‚ùå Falha cr√≠tica no backend")
                input("Pressione Enter para sair...")
                return 1
            
            # Iniciar frontend  
            if not self.iniciar_frontend():
                print("‚ùå Falha cr√≠tica no frontend")
                input("Pressione Enter para sair...")
                return 1
            
            # Abrir navegador
            self.abrir_navegador()
            
            print("\n" + "=" * 60)
            print("üéâ GERENCIADOR DE GRANJAS DE FRANGO EST√Å FUNCIONANDO!")
            print(f"üåê Acesse a aplica√ß√£o em: {FRONTEND_URL}")
            print("üíæ Dados s√£o armazenados em: broiler_data.db")
            print("üìÑ Relat√≥rios s√£o salvos em: exports/")
            print("üáßüá∑ Interface completamente em portugu√™s!")
            print("\n‚ö†Ô∏è  Para parar a aplica√ß√£o: Pressione Ctrl+C ou feche esta janela")
            print("=" * 60)
            
            # Manter a aplica√ß√£o executando
            try:
                while True:
                    time.sleep(1)
                    # Verificar se processos ainda est√£o executando
                    backend_running = self.backend_process and self.backend_process.poll() is None
                    frontend_running = self.frontend_process and self.frontend_process.poll() is None
                    
                    if not backend_running:
                        print("‚ö†Ô∏è  Servidor backend parou inesperadamente")
                        break
                    if not frontend_running:
                        print("‚ö†Ô∏è  Servidor frontend parou inesperadamente")
                        break
                        
            except KeyboardInterrupt:
                print("\n‚ö†Ô∏è Ctrl+C detectado...")
                
        except Exception as e:
            print(f"‚ùå Erro cr√≠tico na aplica√ß√£o: {e}")
            return 1
        finally:
            self.parar_servicos()
            print("\nüëã Aplica√ß√£o encerrada. Obrigado por usar o Gerenciador de Granjas de Frango!")
        
        return 0

if __name__ == "__main__":
    app = GerenciadorGranjaFrango()
    exit_code = app.executar()
    if exit_code != 0:
        input("Pressione Enter para sair...")
    sys.exit(exit_code)